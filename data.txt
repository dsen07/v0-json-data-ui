# node-detail-modal.component
import { Component, Input, Output, EventEmitter, OnChanges, SimpleChanges } from '@angular/core';
import { CommonModule } from '@angular/common';

interface FlattenedNode {
  path: string;
  key: string;
  value: any;
  type: string;
  level: number;
  isExpandable: boolean;
  parentPath: string;
}

@Component({
  selector: 'app-node-detail-modal',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './node-detail-modal.component.html',
  styleUrls: ['./node-detail-modal.component.css']
})
export class NodeDetailModalComponent implements OnChanges {
  @Input() isOpen: boolean = false;
  @Input() nodePath: string = '';
  @Input() nodeData: any;
  @Output() close = new EventEmitter<void>();

  flattenedNodes: FlattenedNode[] = [];
  visibleNodes: FlattenedNode[] = [];
  expandedRows: Set<string> = new Set();
  keyName: string = '';

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['nodeData'] || changes['nodePath']) {
      this.updateNodes();
    }
  }

  updateNodes(): void {
    this.keyName = this.nodePath.split('.').pop() || this.nodePath;
    this.flattenedNodes = this.flattenNode(this.nodeData, this.keyName);
    this.updateVisibleNodes();
  }

  flattenNode(data: any, keyName: string, parentPath = '', level = 0): FlattenedNode[] {
    const results: FlattenedNode[] = [];
    const currentPath = parentPath ? `${parentPath}.${keyName}` : keyName;

    const isObject = data !== null && typeof data === 'object' && !Array.isArray(data);
    const isArray = Array.isArray(data);
    const isExpandable = isObject || isArray;

    let type = typeof data;
    if (data === null) type = 'null';
    else if (isArray) type = 'array';
    else if (isObject) type = 'object';

    results.push({
      path: currentPath,
      key: keyName,
      value: data,
      type,
      level,
      isExpandable,
      parentPath
    });

    if (isArray) {
      data.forEach((item: any, index: number) => {
        results.push(...this.flattenNode(item, `[${index}]`, currentPath, level + 1));
      });
    } else if (isObject) {
      Object.entries(data).forEach(([key, value]) => {
        results.push(...this.flattenNode(value, key, currentPath, level + 1));
      });
    }

    return results;
  }

  toggleRow(path: string): void {
    if (this.expandedRows.has(path)) {
      this.expandedRows.delete(path);
    } else {
      this.expandedRows.add(path);
    }
    this.updateVisibleNodes();
  }

  isRowVisible(node: FlattenedNode): boolean {
    if (node.level === 0) return true;

    const pathParts = node.path.split('.');
    for (let i = 1; i < pathParts.length; i++) {
      const parentPath = pathParts.slice(0, i).join('.');
      if (!this.expandedRows.has(parentPath)) {
        return false;
      }
    }
    return true;
  }

  updateVisibleNodes(): void {
    this.visibleNodes = this.flattenedNodes.filter(node => this.isRowVisible(node));
  }

  onClose(): void {
    this.close.emit();
  }

  onBackdropClick(event: MouseEvent): void {
    if (event.target === event.currentTarget) {
      this.onClose();
    }
  }

  getValueDisplay(node: FlattenedNode): string {
    const { value, type } = node;
    
    if (type === 'null') return 'null';
    if (type === 'boolean') return String(value);
    if (type === 'number') return String(value);
    if (type === 'string') return `"${value}"`;
    if (type === 'array') return `Array(${(value as any[]).length})`;
    if (type === 'object') return `Object(${Object.keys(value).length})`;
    
    return String(value);
  }

  getValueClass(type: string): string {
    const classes: { [key: string]: string } = {
      'null': 'value-null',
      'boolean': 'value-boolean',
      'number': 'value-number',
      'string': 'value-string',
      'array': 'value-complex',
      'object': 'value-complex'
    };
    return classes[type] || '';
  }

  getPaddingLeft(level: number): string {
    return `${level * 16}px`;
  }
}

<div class="modal-backdrop" *ngIf="isOpen" (click)="onBackdropClick($event)">
  <div class="modal-dialog" (click)="$event.stopPropagation()">
    <div class="modal-header">
      <div class="modal-title-container">
        <h2 class="modal-title">Node Details</h2>
        <span class="badge">{{ nodePath }}</span>
      </div>
      <button class="close-button" (click)="onClose()">&times;</button>
    </div>
    
    <p class="modal-description">
      Detailed view of the selected node and all its children for incident investigation and data comparison.
    </p>

    <div class="modal-content">
      <div class="table-container">
        <table class="data-table">
          <thead>
            <tr>
              <th class="col-toggle"></th>
              <th class="col-key">Key</th>
              <th class="col-value">Value</th>
              <th class="col-type">Type</th>
              <th class="col-level">Level</th>
            </tr>
          </thead>
          <tbody>
            <tr *ngFor="let node of visibleNodes" 
                [class.row-root]="node.level === 0"
                class="data-row">
              <td class="cell-toggle">
                <button *ngIf="node.isExpandable"
                        (click)="toggleRow(node.path)"
                        class="toggle-button">
                  <svg *ngIf="expandedRows.has(node.path)" 
                       class="icon" 
                       viewBox="0 0 24 24" 
                       fill="none" 
                       stroke="currentColor" 
                       stroke-width="2">
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                  <svg *ngIf="!expandedRows.has(node.path)" 
                       class="icon" 
                       viewBox="0 0 24 24" 
                       fill="none" 
                       stroke="currentColor" 
                       stroke-width="2">
                    <polyline points="9 18 15 12 9 6"></polyline>
                  </svg>
                </button>
              </td>
              <td class="cell-key">
                <div class="key-wrapper" [style.padding-left]="getPaddingLeft(node.level)">
                  <span class="key-text">{{ node.key }}</span>
                </div>
              </td>
              <td class="cell-value">
                <div class="value-wrapper">
                  <span [class]="getValueClass(node.type)">
                    {{ getValueDisplay(node) }}
                  </span>
                </div>
              </td>
              <td class="cell-type">
                <span class="type-badge">{{ node.type }}</span>
              </td>
              <td class="cell-level">
                <span class="level-text">{{ node.level }}</span>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>

    <div class="modal-footer">
      <span>Total nodes: {{ flattenedNodes.length }}</span>
      <span>Visible nodes: {{ visibleNodes.length }}</span>
    </div>
  </div>
</div>

.modal-backdrop {
  position: fixed;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  animation: fadeIn 0.2s ease-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.modal-dialog {
  background: white;
  border-radius: 8px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
  width: 90%;
  max-width: 1200px;
  max-height: 85vh;
  display: flex;
  flex-direction: column;
  animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
  from {
    transform: scale(0.95);
    opacity: 0;
  }
  to {
    transform: scale(1);
    opacity: 1;
  }
}

.modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 24px 24px 16px;
  border-bottom: 1px solid #e5e7eb;
}

.modal-title-container {
  display: flex;
  align-items: center;
  gap: 8px;
}

.modal-title {
  font-size: 1.25rem;
  font-weight: 600;
  color: #111827;
  margin: 0;
}

.badge {
  font-family: monospace;
  font-size: 0.75rem;
  padding: 4px 8px;
  background-color: #f3f4f6;
  border: 1px solid #d1d5db;
  border-radius: 4px;
  color: #374151;
}

.close-button {
  background: none;
  border: none;
  font-size: 2rem;
  line-height: 1;
  color: #6b7280;
  cursor: pointer;
  padding: 0;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.2s;
}

.close-button:hover {
  color: #111827;
  background-color: #f3f4f6;
}

.modal-description {
  padding: 0 24px 16px;
  color: #6b7280;
  font-size: 0.875rem;
  margin: 0;
}

.modal-content {
  flex: 1;
  overflow: auto;
  margin: 0 24px;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
}

.table-container {
  width: 100%;
  overflow-x: auto;
}

.data-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
}

.data-table thead {
  position: sticky;
  top: 0;
  background-color: white;
  z-index: 10;
  border-bottom: 1px solid #e5e7eb;
}

.data-table th {
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  color: #374151;
  background-color: #f9fafb;
}

.col-toggle {
  width: 40px;
}

.col-key {
  width: 250px;
}

.col-type {
  width: 100px;
}

.col-level {
  width: 80px;
  text-align: center;
}

.data-row {
  border-bottom: 1px solid #f3f4f6;
  transition: background-color 0.15s;
}

.data-row:hover {
  background-color: #f9fafb;
}

.row-root {
  background-color: #f3f4f6;
  font-weight: 500;
}

.data-table td {
  padding: 12px 16px;
}

.cell-toggle {
  width: 40px;
}

.toggle-button {
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  color: #6b7280;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: color 0.2s;
}

.toggle-button:hover {
  color: #111827;
}

.icon {
  width: 16px;
  height: 16px;
}

.key-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
}

.key-text {
  font-family: monospace;
  font-size: 0.875rem;
}

.value-wrapper {
  max-width: 600px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.value-null {
  color: #6b7280;
  font-style: italic;
  font-family: monospace;
}

.value-boolean {
  color: #3b82f6;
  font-family: monospace;
}

.value-number {
  color: #8b5cf6;
  font-family: monospace;
}

.value-string {
  color: #10b981;
  font-family: monospace;
  word-break: break-all;
}

.value-complex {
  color: #6b7280;
  font-family: monospace;
}

.type-badge {
  display: inline-block;
  padding: 2px 8px;
  background-color: #f3f4f6;
  border-radius: 4px;
  font-size: 0.75rem;
  color: #374151;
  font-weight: 500;
}

.cell-level {
  text-align: center;
}

.level-text {
  color: #6b7280;
  font-size: 0.875rem;
}

.modal-footer {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 24px;
  border-top: 1px solid #e5e7eb;
  color: #6b7280;
  font-size: 0.875rem;
}


## Structured-view:
import { Component, Input, OnInit, OnChanges, SimpleChanges, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NodeDetailModalComponent } from './node-detail-modal.component';

interface TreeNodeData {
  key: string;
  value: any;
  path: string;
}

@Component({
  selector: 'app-structured-view',
  standalone: true,
  imports: [CommonModule, NodeDetailModalComponent],
  templateUrl: './structured-view-with-modal.component.html',
  styleUrls: ['./structured-view-with-modal.component.css']
})
export class StructuredViewWithModalComponent implements OnInit, OnChanges {
  @Input() data: any;
  @Input() searchTerm: string = '';
  @Input() currentResultIndex: number = 0;
  @Input() filterMode: 'filter' | 'highlight' = 'highlight';
  @Output() searchResultsChange = new EventEmitter<string[]>();

  debouncedSearchTerm: string = '';
  matchOrder: string[] = [];
  matchedPaths: Set<string> = new Set();
  rootEntries: TreeNodeData[] = [];
  private debounceTimer: any;

  modalOpen: boolean = false;
  selectedNode: { path: string; data: any } | null = null;

  ngOnInit(): void {
    this.updateSearchResults();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['searchTerm']) {
      if (this.debounceTimer) {
        clearTimeout(this.debounceTimer);
      }
      this.debounceTimer = setTimeout(() => {
        this.debouncedSearchTerm = this.searchTerm;
        this.updateSearchResults();
      }, 300);
    }

    if (changes['data'] || changes['filterMode']) {
      this.updateSearchResults();
    }
  }

  updateSearchResults(): void {
    this.matchOrder = this.collectMatchingPathsInOrder(this.data, this.debouncedSearchTerm);
    this.matchedPaths = new Set(this.matchOrder);
    this.searchResultsChange.emit(this.matchOrder);
    this.updateRootEntries();
  }

  collectMatchingPathsInOrder(data: any, searchTerm: string): string[] {
    const matchedPaths: string[] = [];
    if (!searchTerm) return matchedPaths;

    const searchLower = searchTerm.toLowerCase();

    const traverse = (obj: any, currentPath: string) => {
      if (obj === null || typeof obj !== 'object') {
        return;
      }

      if (Array.isArray(obj)) {
        obj.forEach((item, index) => {
          const itemPath = currentPath ? `${currentPath}.${index}` : `${index}`;
          const keyMatches = `[${index}]`.toLowerCase().includes(searchLower);
          const isExpandable = item !== null && typeof item === 'object';
          const valueMatches = !isExpandable && String(item).toLowerCase().includes(searchLower);

          if (keyMatches || valueMatches) {
            matchedPaths.push(itemPath);
          }

          traverse(item, itemPath);
        });
      } else {
        Object.entries(obj).forEach(([key, value]) => {
          const valuePath = currentPath ? `${currentPath}.${key}` : key;
          const keyMatches = key.toLowerCase().includes(searchLower);
          const isExpandable = value !== null && typeof value === 'object';
          const valueMatches = !isExpandable && String(value).toLowerCase().includes(searchLower);

          if (keyMatches || valueMatches) {
            matchedPaths.push(valuePath);
          }

          traverse(value, valuePath);
        });
      }
    };

    traverse(data, '');
    return matchedPaths;
  }

  updateRootEntries(): void {
    if (!this.data) {
      this.rootEntries = [];
      return;
    }

    const entries = Object.entries(this.data);

    if (this.filterMode === 'highlight' || !this.debouncedSearchTerm) {
      this.rootEntries = entries.map(([key, value]) => ({
        key,
        value,
        path: key
      }));
    } else {
      this.rootEntries = entries
        .filter(([key]) => this.shouldShowNode(key, this.matchedPaths, this.debouncedSearchTerm))
        .map(([key, value]) => ({
          key,
          value,
          path: key
        }));
    }
  }

  shouldShowNode(path: string, matchedPaths: Set<string>, searchTerm: string): boolean {
    if (!searchTerm) return true;
    if (matchedPaths.has(path)) return true;

    for (const matchedPath of matchedPaths) {
      if (matchedPath.startsWith(path + '.')) {
        return true;
      }
    }

    return false;
  }

  handleNodeClick(path: string, nodeData: any): void {
    this.selectedNode = { path, data: nodeData };
    this.modalOpen = true;
  }

  closeModal(): void {
    this.modalOpen = false;
  }

  get isSearching(): boolean {
    return this.searchTerm !== this.debouncedSearchTerm;
  }

  get showNoResults(): boolean {
    return this.debouncedSearchTerm.length > 0 && 
           this.rootEntries.length === 0 && 
           this.filterMode === 'filter';
  }
}

<div class="structured-view-container">
  <div class="content-wrapper">
    <div *ngIf="isSearching" class="search-indicator">
      <svg class="spinner" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4" fill="none"/>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
      </svg>
      Searching...
    </div>

    <app-tree-node *ngFor="let entry of rootEntries"
                   [keyName]="entry.key"
                   [value]="entry.value"
                   [level]="0"
                   [path]="entry.path"
                   [searchTerm]="debouncedSearchTerm"
                   [currentResultIndex]="currentResultIndex"
                   [matchedPaths]="matchedPaths"
                   [matchOrder]="matchOrder"
                   [filterMode]="filterMode"
                   (nodeClick)="handleNodeClick($event.path, $event.value)">
    </app-tree-node>

    <div *ngIf="showNoResults" class="no-results">
      <div class="no-results-content">
        <p class="no-results-text">No matches found for "{{ debouncedSearchTerm }}"</p>
        <p class="no-results-hint">Try a different search term</p>
      </div>
    </div>
  </div>
</div>

<app-node-detail-modal
  [isOpen]="modalOpen"
  [nodePath]="selectedNode?.path || ''"
  [nodeData]="selectedNode?.data"
  (close)="closeModal()">
</app-node-detail-modal>

.structured-view-container {
  height: 100%;
  overflow: auto;
  padding: 16px;
}

.content-wrapper {
  width: 100%;
}

.search-indicator {
  margin-bottom: 12px;
  padding: 8px 12px;
  background-color: #eff6ff;
  border: 1px solid: #bfdbfe;
  border-radius: 6px;
  font-size: 0.875rem;
  color: #1e40af;
  display: flex;
  align-items: center;
  gap: 8px;
}

.spinner {
  width: 16px;
  height: 16px;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

.no-results {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #6b7280;
}

.no-results-content {
  text-align: center;
}

.no-results-text {
  font-size: 0.875rem;
  margin: 0 0 4px 0;
}

.no-results-hint {
  font-size: 0.75rem;
  margin: 0;
}


## Tee-Node Components:
import { Component, Input, OnInit, OnChanges, SimpleChanges, Output, EventEmitter, ElementRef, ViewChild } from '@angular/core';
import { CommonModule } from '@angular/common';

interface ChildNode {
  key: string;
  value: any;
  path: string;
}

@Component({
  selector: 'app-tree-node',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './tree-node.component.html',
  styleUrls: ['./tree-node.component.css']
})
export class TreeNodeComponent implements OnInit, OnChanges {
  @Input() keyName: string = '';
  @Input() value: any;
  @Input() level: number = 0;
  @Input() path: string = '';
  @Input() searchTerm: string = '';
  @Input() currentResultIndex: number = 0;
  @Input() matchedPaths: Set<string> = new Set();
  @Input() matchOrder: string[] = [];
  @Input() filterMode: 'filter' | 'highlight' = 'highlight';
  @Output() nodeClick = new EventEmitter<{ path: string; value: any }>();

  @ViewChild('nodeElement') nodeElement?: ElementRef;

  isExpanded: boolean = true;
  isObject: boolean = false;
  isArray: boolean = false;
  isExpandable: boolean = false;
  keyMatches: boolean = false;
  valueMatches: boolean = false;
  isMatch: boolean = false;
  matchIndex: number = -1;
  isCurrentMatch: boolean = false;
  filteredChildren: ChildNode[] = [];
  shouldShow: boolean = true;

  ngOnInit(): void {
    this.updateNodeState();
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['value'] || changes['searchTerm'] || changes['matchedPaths'] || 
        changes['currentResultIndex'] || changes['filterMode']) {
      this.updateNodeState();
    }

    if (changes['searchTerm'] && this.searchTerm) {
      if (this.shouldShowNode(this.path, this.matchedPaths, this.searchTerm)) {
        this.isExpanded = true;
      }
    }

    if (this.isCurrentMatch) {
      setTimeout(() => this.scrollToNode(), 100);
    }
  }

  updateNodeState(): void {
    this.isObject = this.value !== null && typeof this.value === 'object' && !Array.isArray(this.value);
    this.isArray = Array.isArray(this.value);
    this.isExpandable = this.isObject || this.isArray;

    const searchLower = this.searchTerm.toLowerCase();
    this.keyMatches = this.searchTerm && this.keyName.toLowerCase().includes(searchLower);
    this.valueMatches = this.searchTerm && !this.isExpandable && String(this.value).toLowerCase().includes(searchLower);

    this.isMatch = this.matchedPaths.has(this.path);
    this.matchIndex = this.matchOrder.indexOf(this.path);
    this.isCurrentMatch = this.isMatch && this.matchIndex === this.currentResultIndex;

    this.filteredChildren = this.isExpandable && this.isExpanded ? this.getFilteredChildren() : [];
    this.shouldShow = this.filterMode === 'highlight' || this.shouldShowNode(this.path, this.matchedPaths, this.searchTerm);
  }

  toggleExpanded(): void {
    this.isExpanded = !this.isExpanded;
    this.updateNodeState();
  }

  getFilteredChildren(): ChildNode[] {
    const children: ChildNode[] = [];

    if (this.isArray) {
      this.value.forEach((item: any, index: number) => {
        const childPath = `${this.path}.${index}`;
        const childKey = `[${index}]`;

        if (this.filterMode === 'highlight' || this.shouldShowNode(childPath, this.matchedPaths, this.searchTerm)) {
          children.push({ key: childKey, value: item, path: childPath });
        }
      });
    } else if (this.isObject) {
      Object.entries(this.value).forEach(([key, val]) => {
        const childPath = `${this.path}.${key}`;

        if (this.filterMode === 'highlight' || this.shouldShowNode(childPath, this.matchedPaths, this.searchTerm)) {
          children.push({ key, value: val, path: childPath });
        }
      });
    }

    return children;
  }

  shouldShowNode(path: string, matchedPaths: Set<string>, searchTerm: string): boolean {
    if (!searchTerm) return true;
    if (matchedPaths.has(path)) return true;

    for (const matchedPath of matchedPaths) {
      if (matchedPath.startsWith(path + '.')) {
        return true;
      }
    }

    return false;
  }

  renderValue(val: any): string {
    if (val === null) return 'null';
    if (typeof val === 'boolean') return String(val);
    if (typeof val === 'number') return String(val);
    if (typeof val === 'string') return `"${val}"`;
    return '';
  }

  getValueClass(val: any): string {
    if (val === null) return 'value-null';
    if (typeof val === 'boolean') return 'value-boolean';
    if (typeof val === 'number') return 'value-number';
    if (typeof val === 'string') return 'value-string';
    return '';
  }

  highlightText(text: string, shouldHighlight: boolean): string {
    if (!shouldHighlight || !this.searchTerm) return text;

    const searchLower = this.searchTerm.toLowerCase();
    return text.replace(new RegExp(`(${this.searchTerm})`, 'gi'), match => 
      `<mark class="highlight">${match}</mark>`
    );
  }

  getCollapsedText(): string {
    if (this.searchTerm && this.filterMode === 'filter') {
      return `Filtered(${this.filteredChildren.length})`;
    }
    if (this.isArray) {
      return `Array(${this.value.length})`;
    }
    if (this.isObject) {
      return `Object(${Object.keys(this.value).length})`;
    }
    return '';
  }

  getPaddingLeft(): string {
    return `${this.level * 24 + 12}px`;
  }

  onNodeClickHandler(): void {
    this.nodeClick.emit({ path: this.path, value: this.value });
  }

  scrollToNode(): void {
    if (this.nodeElement) {
      const element = this.nodeElement.nativeElement;
      const scrollContainer = element.closest('.overflow-auto');
      
      if (scrollContainer) {
        const containerRect = scrollContainer.getBoundingClientRect();
        const nodeRect = element.getBoundingClientRect();
        
        const isFullyVisible = nodeRect.top >= containerRect.top && nodeRect.bottom <= containerRect.bottom;
        
        if (!isFullyVisible) {
          const containerHeight = containerRect.height;
          const nodeHeight = nodeRect.height;
          const currentScrollTop = scrollContainer.scrollTop;
          const nodeRelativeTop = nodeRect.top - containerRect.top;
          
          const targetScrollTop = currentScrollTop + nodeRelativeTop - containerHeight / 2 + nodeHeight / 2;
          
          scrollContainer.scrollTo({
            top: Math.max(0, targetScrollTop),
            behavior: 'smooth'
          });
        }
      }
    }
  }
}

<div #nodeElement *ngIf="shouldShow" class="tree-node-wrapper">
  <div class="tree-node" 
       [class.current-match]="isCurrentMatch"
       [style.padding-left]="getPaddingLeft()">
    
    <button *ngIf="isExpandable"
            (click)="toggleExpanded()"
            class="expand-button">
      <svg *ngIf="isExpanded" class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
      <svg *ngIf="!isExpanded" class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    </button>
    <div *ngIf="!isExpandable" class="spacer"></div>

    <div class="node-content">
      <div class="key-section">
        <span class="key-name" [class.key-match]="keyMatches" [innerHTML]="highlightText(keyName, keyMatches)"></span>:
        <span *ngIf="isMatch" class="match-badge">Match</span>
      </div>

      <div *ngIf="!isExpandable" class="value-section">
        <span [class]="getValueClass(value)" [innerHTML]="valueMatches ? highlightText(String(value), true) : renderValue(value)"></span>
      </div>

      <span *ngIf="isExpandable && !isExpanded" class="collapsed-info">
        {{ getCollapsedText() }}
      </span>
    </div>

    <button *ngIf="isExpandable"
            (click)="onNodeClickHandler()"
            class="table-button"
            title="View in table format">
      <svg class="icon-sm" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="7" height="7"></rect>
        <rect x="14" y="3" width="7" height="7"></rect>
        <rect x="14" y="14" width="7" height="7"></rect>
        <rect x="3" y="14" width="7" height="7"></rect>
      </svg>
    </button>
  </div>

  <div *ngIf="isExpandable && isExpanded">
    <app-tree-node *ngFor="let child of filteredChildren"
                   [keyName]="child.key"
                   [value]="child.value"
                   [level]="level + 1"
                   [path]="child.path"
                   [searchTerm]="searchTerm"
                   [currentResultIndex]="currentResultIndex"
                   [matchedPaths]="matchedPaths"
                   [matchOrder]="matchOrder"
                   [filterMode]="filterMode"
                   (nodeClick)="nodeClick.emit($event)">
    </app-tree-node>
  </div>
</div>

.tree-node-wrapper {
  transition: opacity 0.2s;
}

.tree-node {
  display: flex;
  align-items: flex-start;
  gap: 8px;
  padding: 6px 12px;
  border-radius: 6px;
  transition: background-color 0.2s;
}

.tree-node:hover {
  background-color: #f9fafb;
}

.tree-node:hover .table-button {
  opacity: 1;
}

.current-match {
  background-color: #dbeafe !important;
  box-shadow: 0 0 0 2px #3b82f6;
}

.expand-button {
  flex-shrink: 0;
  margin-top: 2px;
  background: none;
  border: none;
  padding: 0;
  cursor: pointer;
  color: #6b7280;
  transition: color 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.expand-button:hover {
  color: #111827;
}

.spacer {
  width: 16px;
  flex-shrink: 0;
}

.icon {
  width: 16px;
  height: 16px;
}

.icon-sm {
  width: 14px;
  height: 14px;
}

.node-content {
  flex: 1;
  min-width: 0;
  display: flex;
  align-items: flex-start;
  gap: 12px;
}

.key-section {
  display: flex;
  align-items: center;
  gap: 8px;
  flex-shrink: 0;
}

.key-name {
  font-family: monospace;
  font-size: 0.875rem;
  font-weight: 500;
  color: #6b7280;
}

.key-match {
  color: #111827;
}

.match-badge {
  display: inline-block;
  height: 20px;
  padding: 0 8px;
  background-color: #f3f4f6;
  border-radius: 4px;
  font-size: 0.75rem;
  line-height: 20px;
  color: #374151;
}

.value-section {
  font-family: monospace;
  font-size: 0.875rem;
  word-break: break-all;
}

.value-null {
  color: #6b7280;
  font-style: italic;
}

.value-boolean {
  color: #3b82f6;
}

.value-number {
  color: #8b5cf6;
}

.value-string {
  color: #10b981;
}

.collapsed-info {
  font-size: 0.875rem;
  color: #6b7280;
}

.table-button {
  opacity: 0;
  transition: opacity 0.2s;
  background: none;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  color: #6b7280;
  border-radius: 4px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.table-button:hover {
  background-color: #f3f4f6;
  color: #111827;
}

:host ::ng-deep .highlight {
  background-color: #fef08a;
  color: #111827;
  border-radius: 2px;
  padding: 0 2px;
}
        
